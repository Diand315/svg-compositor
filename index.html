<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="author" content="Rock_4762">
    <meta name="description" content="A powerful SVG composition tool built with React.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Compositor v1.2</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body { background-color: #f8fafc; font-family: system-ui, -apple-system, sans-serif; }
        .canvas-area { 
            background-color: #e2e8f0;
            background-image: 
                linear-gradient(45deg, #cbd5e1 25%, transparent 25%), 
                linear-gradient(-45deg, #cbd5e1 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #cbd5e1 75%), 
                linear-gradient(-45deg, transparent 75%, #cbd5e1 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            overflow: hidden;
            cursor: default;
        }
        .canvas-area:active { cursor: grabbing; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        
        .svg-editor-selected {
            outline: 2px dashed #ef4444 !important;
            opacity: 0.8;
            cursor: pointer;
        }
        .svg-editor-hover:hover {
            outline: 1px solid #6366f1;
            cursor: pointer;
        }
        .bg-checkerboard {
            background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEwIDBoMTB2MTBIMTB6TTAgMTBoMTB2MTBIMHoiIGZpbGw9IiNlMmU4ZjAiIGZpbGwtb3BhY2l0eT0iMC41Ii8+PC9zdmc+');
        }
        .lang-select {
            background-color: #334155;
            color: white;
            border: 1px solid #475569;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            outline: none;
        }
        .lang-select:hover {
            background-color: #475569;
        }
        .selection-box {
            position: absolute;
            background-color: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.8);
            pointer-events: none;
            z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const TRANSLATIONS = {
            'zh-TW': {
                title: "SVG 合成器 v1.2",
                subtitle: "中鍵: 移動畫布 | 滾輪: 縮放",
                smartTrim: "Smart Trim (自動裁切空白)",
                previewWhiteBg: "預覽顯示白底 (下載時自動透明)",
                canvasSize: "畫布尺寸",
                upload: "上傳 / 追加\n拖曳檔案至此",
                deleteLayer: "刪除圖層",
                clearFilesConfirm: "確定清空此組所有檔案?",
                deleteLayerConfirm: "確定刪除此圖層組?",
                editSvg: "編輯此 SVG (清理/群組)",
                fileCount: "共 {count} 個檔案 (目前: {name})",
                addOther: "新增其他圖層",
                batchDownload: "批量下載 (透明背景)",
                reset: "置中",
                delete: "刪除",
                group: "群組",
                ungroup: "取消群組",
                extract: "提取至新圖層",
                editorTitle: "編輯 SVG: {name}",
                editorSubtitle: "提示: 左鍵拖曳框選(穿透群組), Shift+點擊多選, 中鍵平移",
                previewWhite: "預覽白底",
                cancel: "取消",
                save: "儲存變更",
                extractAlert: "請單選提取。",
                noFileAlert: "無檔案！",
                dropHere: "放開以開始上傳"
            },
            'zh-CN': {
                title: "SVG 合成器 v1.2",
                subtitle: "中键: 移动画布 | 滚轮: 缩放",
                smartTrim: "Smart Trim (自动裁切空白)",
                previewWhiteBg: "预览显示白底 (下载时自动透明)",
                canvasSize: "画布尺寸",
                upload: "上传 / 追加\n拖拽文件至此",
                deleteLayer: "删除图层",
                clearFilesConfirm: "确定清空此组所有文件?",
                deleteLayerConfirm: "确定删除此图层组?",
                editSvg: "编辑此 SVG (清理/群组)",
                fileCount: "共 {count} 个文件 (当前: {name})",
                addOther: "添加其他图层",
                batchDownload: "批量下载 (透明背景)",
                reset: "居中",
                delete: "删除",
                group: "群组",
                ungroup: "取消群组",
                extract: "提取至新图层",
                editorTitle: "编辑 SVG: {name}",
                editorSubtitle: "提示: 左键拖曳框选(穿透群组), Shift+点击多选, 中键平移",
                previewWhite: "预览白底",
                cancel: "取消",
                save: "保存更改",
                extractAlert: "请单选提取。",
                noFileAlert: "无文件！",
                dropHere: "放开以开始上传"
            },
            'en-US': {
                title: "SVG Compositor v1.2",
                subtitle: "Middle Click: Pan | Wheel: Zoom",
                smartTrim: "Smart Trim (Auto-crop whitespace)",
                previewWhiteBg: "Preview White BG (Transparent on Download)",
                canvasSize: "CANVAS SIZE",
                upload: "Upload / Append\nDrag & Drop Here",
                deleteLayer: "Delete Layer",
                clearFilesConfirm: "Clear all files in this group?",
                deleteLayerConfirm: "Delete this layer group?",
                editSvg: "Edit SVG (Clean/Group)",
                fileCount: "{count} files total (Current: {name})",
                addOther: "Add Other Layer",
                batchDownload: "Batch Download (Transparent BG)",
                reset: "Center",
                delete: "Delete",
                group: "Group",
                ungroup: "Ungroup",
                extract: "Extract to New Layer",
                editorTitle: "Edit SVG: {name}",
                editorSubtitle: "Tip: Box Select (Deep), Shift+Click Multi-select, Mid-Click Pan",
                previewWhite: "White BG",
                cancel: "Cancel",
                save: "Save Changes",
                extractAlert: "Please select a single item to extract.",
                noFileAlert: "No files!",
                dropHere: "Release to Upload"
            }
        };

        const Icon = ({ name, size = 16, className = "" }) => {
            useEffect(() => { lucide.createIcons(); }, [name]);
            return <i data-lucide={name} style={{width: size, height: size}} className={className}></i>;
        };

        // --- Modified UploadZone to support multiline text ---
        const UploadZone = ({ groupId, onUpload, t }) => {
            const [isDragging, setIsDragging] = useState(false);
            const handleDragOver = (e) => { e.preventDefault(); setIsDragging(true); };
            const handleDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };
            const handleDrop = (e) => { e.preventDefault(); setIsDragging(false); if (e.dataTransfer.files.length) onUpload(groupId, e.dataTransfer.files); };
            const handleFileChange = (e) => { if (e.target.files.length) onUpload(groupId, e.target.files); };
            
            return (
                <label className={`flex-1 flex items-center justify-center gap-2 py-3 border-2 border-dashed rounded-xl cursor-pointer transition-all ${isDragging ? 'border-indigo-500 bg-indigo-50 text-indigo-600 scale-[1.02]' : 'border-slate-300 hover:border-indigo-500 text-slate-500 hover:text-indigo-600 bg-white'}`} onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}>
                    <Icon name={isDragging ? "arrow-down-circle" : "upload-cloud"} size={16} />
                    {/* Added whitespace-pre-line and text-center to support line breaks */}
                    <span className="text-xs font-bold whitespace-pre-line text-center leading-tight">
                        {isDragging ? t('dropHere') : t('upload')}
                    </span>
                    <input type="file" multiple accept=".svg" className="hidden" onChange={handleFileChange} />
                </label>
            );
        };

        const SvgEditorModal = ({ file, parentGroupInfo, onSave, onPromote, onClose, t }) => {
            const containerRef = useRef(null);
            const editorWrapperRef = useRef(null);
            const [selectionCount, setSelectionCount] = useState(0);
            
            const [scale, setScale] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [startPan, setStartPan] = useState({ x: 0, y: 0 });
            const [editorWhiteBg, setEditorWhiteBg] = useState(true);

            // --- Box Selection State ---
            const [isBoxSelecting, setIsBoxSelecting] = useState(false);
            const [selectionBox, setSelectionBox] = useState({ x: 0, y: 0, w: 0, h: 0 });
            const [boxStart, setBoxStart] = useState({ x: 0, y: 0 });

            useEffect(() => {
                if (containerRef.current) {
                    const fullSvgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="${file.viewBox}" style="overflow: visible;">${file.content}</svg>`;
                    containerRef.current.innerHTML = fullSvgContent;
                    attachEvents();
                }
            }, []);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'g' || e.key === 'G') { e.preventDefault(); e.shiftKey ? handleUngroup() : handleGroup(); }
                        else if (e.key === 'a' || e.key === 'A') { e.preventDefault(); handleSelectAll(); }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectionCount]);

            const handleWheel = (e) => {
                e.stopPropagation();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                setScale(prev => Math.min(Math.max(0.1, prev + delta), 5));
            };

            const getMousePos = (e) => {
                if (!editorWrapperRef.current) return { x: 0, y: 0 };
                const rect = editorWrapperRef.current.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            };

            const handleMouseDown = (e) => {
                if (e.button === 1) {
                    e.preventDefault(); e.stopPropagation();
                    setIsPanning(true); setStartPan({ x: e.clientX - pan.x, y: e.clientY - pan.y });
                    return;
                }
                if (e.button === 0) {
                    const targetEl = e.target.closest('.svg-editor-hover');
                    if (!targetEl || e.target === containerRef.current.querySelector('svg')) {
                         if (!e.shiftKey) clearSelection();
                         setIsBoxSelecting(true);
                         const pos = getMousePos(e);
                         setBoxStart(pos);
                         setSelectionBox({ x: pos.x, y: pos.y, w: 0, h: 0 });
                    }
                }
            };

            const handleMouseMove = (e) => {
                if (isPanning) {
                    e.preventDefault(); e.stopPropagation();
                    setPan({ x: e.clientX - startPan.x, y: e.clientY - startPan.y });
                    return;
                }
                if (isBoxSelecting) {
                    const pos = getMousePos(e);
                    const newX = Math.min(pos.x, boxStart.x);
                    const newY = Math.min(pos.y, boxStart.y);
                    const newW = Math.abs(pos.x - boxStart.x);
                    const newH = Math.abs(pos.y - boxStart.y);
                    setSelectionBox({ x: newX, y: newY, w: newW, h: newH });
                }
            };

            const handleMouseUp = (e) => {
                if (isPanning) { setIsPanning(false); return; }
                if (isBoxSelecting) {
                    setIsBoxSelecting(false);
                    applyBoxSelection(selectionBox, e.shiftKey);
                    setSelectionBox({ x: 0, y: 0, w: 0, h: 0 });
                }
            };

            const applyBoxSelection = (box, appendSelection) => {
                if (!containerRef.current) return;
                if (box.w < 5 && box.h < 5) return;
                const allElements = containerRef.current.querySelectorAll('.svg-editor-hover');
                const wrapperRect = editorWrapperRef.current.getBoundingClientRect();
                allElements.forEach(el => {
                    const tagName = el.tagName.toLowerCase();
                    const isGroup = tagName === 'g' || tagName === 'svg' || tagName === 'switch';
                    if (isGroup) return; 
                    const elRect = el.getBoundingClientRect();
                    const elRel = { x: elRect.left - wrapperRect.left, y: elRect.top - wrapperRect.top, w: elRect.width, h: elRect.height };
                    const isOverlapping = (box.x < elRel.x + elRel.w && box.x + box.w > elRel.x && box.y < elRel.y + elRel.h && box.y + box.h > elRel.y);
                    if (isOverlapping) { el.classList.add('svg-editor-selected'); }
                });
                updateSelectionCount();
            };

            const attachEvents = () => {
                const svgRoot = containerRef.current.querySelector('svg');
                if (!svgRoot) return;
                const processNode = (el) => {
                    const tagName = el.tagName.toLowerCase();
                    const isContainer = ['g', 'svg', 'switch', 'defs', 'symbol'].includes(tagName);
                    if (el.nodeType === 1) { 
                        if (!isContainer) { el.classList.add('svg-editor-hover'); }
                        Array.from(el.children).forEach(processNode);
                    }
                };
                processNode(svgRoot);
                svgRoot.onmousedown = (e) => {
                    if (e.button !== 0) return;
                    const target = e.target.closest('.svg-editor-hover');
                    if (target) {
                        e.stopPropagation();
                        const isSelected = target.classList.contains('svg-editor-selected');
                        if (!e.shiftKey) clearSelection();
                        if (e.shiftKey && isSelected) target.classList.remove('svg-editor-selected');
                        else target.classList.add('svg-editor-selected');
                        updateSelectionCount();
                    }
                };
            };

            const clearSelection = () => {
                const selected = containerRef.current.querySelectorAll('.svg-editor-selected');
                selected.forEach(el => el.classList.remove('svg-editor-selected'));
                updateSelectionCount();
            };
            
            const handleSelectAll = () => {
                if (!containerRef.current) return;
                containerRef.current.querySelectorAll('.svg-editor-hover').forEach(el => el.classList.add('svg-editor-selected'));
                updateSelectionCount();
            };

            const updateSelectionCount = () => {
                setSelectionCount(containerRef.current.querySelectorAll('.svg-editor-selected').length);
            };

            const handleDelete = () => {
                containerRef.current.querySelectorAll('.svg-editor-selected').forEach(el => el.remove());
                clearSelection();
            };

            const handleGroup = () => {
                const selected = Array.from(containerRef.current.querySelectorAll('.svg-editor-selected'));
                if (selected.length < 1) return;
                const firstParent = selected[0].parentNode;
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                firstParent.insertBefore(g, selected[0]);
                selected.forEach(el => { el.classList.remove('svg-editor-selected'); g.appendChild(el); });
                Array.from(g.children).forEach(child => child.classList.add('svg-editor-selected'));
                updateSelectionCount();
            };

            const handleUngroup = () => {
                const selected = containerRef.current.querySelectorAll('.svg-editor-selected');
                let changed = false;
                const parentsToUngroup = new Set();
                selected.forEach(el => { if (el.parentNode && el.parentNode.tagName.toLowerCase() === 'g') { parentsToUngroup.add(el.parentNode); } });
                parentsToUngroup.forEach(parentGroup => {
                    const grandParent = parentGroup.parentNode;
                    while (parentGroup.firstChild) {
                        const child = parentGroup.firstChild;
                        grandParent.insertBefore(child, parentGroup);
                    }
                    parentGroup.remove();
                    changed = true;
                });
                if (changed) { updateSelectionCount(); }
            };

            const handleExtract = () => {
                const selected = Array.from(containerRef.current.querySelectorAll('.svg-editor-selected'));
                if (selected.length === 0) return alert(t('extractAlert'));
                let contentToExport = "";
                let bbox = { x: Infinity, y: Infinity, right: -Infinity, bottom: -Infinity };
                selected.forEach(el => {
                    try {
                        const b = el.getBBox();
                        bbox.x = Math.min(bbox.x, b.x); bbox.y = Math.min(bbox.y, b.y);
                        bbox.right = Math.max(bbox.right, b.x + b.width); bbox.bottom = Math.max(bbox.bottom, b.y + b.height);
                    } catch(e) {}
                });
                const width = bbox.right - bbox.x; const height = bbox.bottom - bbox.y;
                if (!isFinite(width)) return;
                const serializer = new XMLSerializer();
                if (selected.length === 1) { contentToExport = serializer.serializeToString(selected[0]); } 
                else { contentToExport = "<g>" + selected.map(el => serializer.serializeToString(el)).join('') + "</g>"; }
                const vb = file.viewBox.split(' ').map(parseFloat);
                const scaleX = parentGroupInfo.w / vb[2]; const scaleY = parentGroupInfo.h / vb[3];
                const newX = parentGroupInfo.x + (bbox.x - vb[0]) * scaleX; const newY = parentGroupInfo.y + (bbox.y - vb[1]) * scaleY;
                onPromote({ content: contentToExport, x: newX, y: newY, w: width * scaleX, h: height * scaleY, viewBox: `${bbox.x} ${bbox.y} ${width} ${height}` });
                selected.forEach(el => el.remove());
                clearSelection();
            };

            const handleSaveInternal = () => {
                const svg = containerRef.current.querySelector('svg');
                if (!svg) return;
                const cleanSvg = svg.cloneNode(true);
                cleanSvg.querySelectorAll('*').forEach(el => {
                    el.classList.remove('svg-editor-hover', 'svg-editor-selected');
                    if (el.classList.length === 0) el.removeAttribute('class');
                });
                onSave(cleanSvg.innerHTML);
            };

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-10" onWheel={(e)=>e.stopPropagation()}>
                    <div className="bg-white rounded-2xl w-full h-full max-w-7xl flex flex-col shadow-2xl overflow-hidden relative">
                        <div className="bg-slate-900 text-white p-4 flex justify-between items-center select-none">
                            <div className="flex flex-col">
                                <h2 className="font-bold flex items-center gap-2"><Icon name="edit-3" /> {t('editorTitle').replace('{name}', file.name)}</h2>
                                <div className="text-[10px] text-slate-400 mt-1">{t('editorSubtitle')}</div>
                            </div>
                            <div className="flex items-center gap-4">
                                <label className="flex items-center gap-2 text-xs cursor-pointer select-none text-slate-300 hover:text-white transition-colors border-r border-slate-700 pr-4 mr-2">
                                    <input type="checkbox" checked={editorWhiteBg} onChange={e => setEditorWhiteBg(e.target.checked)} className="rounded text-indigo-500 focus:ring-indigo-500" /> <span>{t('previewWhite')}</span>
                                </label>
                                <button onClick={onClose} className="px-4 py-2 text-sm hover:text-white text-slate-300">{t('cancel')}</button>
                                <button onClick={handleSaveInternal} className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-bold shadow-lg shadow-indigo-500/30">{t('save')}</button>
                            </div>
                        </div>

                        <div className="bg-slate-50 border-b p-2 flex gap-2 justify-center select-none">
                             <div className="flex items-center gap-1 mr-4 border-r pr-4">
                                <button onClick={() => setScale(s => Math.max(0.1, s-0.1))} className="p-1 hover:bg-slate-200 rounded"><Icon name="minus" size={14}/></button>
                                <span className="text-xs font-mono w-10 text-center">{Math.round(scale*100)}%</span>
                                <button onClick={() => setScale(s => Math.min(5, s+0.1))} className="p-1 hover:bg-slate-200 rounded"><Icon name="plus" size={14}/></button>
                                <button onClick={() => { setScale(1); setPan({x:0,y:0}); }} className="ml-1 text-xs px-2 py-1 bg-white border rounded hover:bg-slate-100">{t('reset')}</button>
                            </div>
                            <button onClick={handleDelete} disabled={selectionCount === 0} className="flex items-center gap-2 px-3 py-1.5 text-xs bg-white border border-slate-300 rounded hover:bg-red-50 hover:text-red-600 disabled:opacity-50 transition-colors"><Icon name="trash-2" size={14} /> {t('delete')} ({selectionCount})</button>
                            <button onClick={handleGroup} disabled={selectionCount === 0} className="flex items-center gap-2 px-3 py-1.5 text-xs bg-white border border-slate-300 rounded hover:bg-indigo-50 hover:text-indigo-600 disabled:opacity-50 transition-colors"><Icon name="box-select" size={14} /> {t('group')}</button>
                            <button onClick={handleUngroup} disabled={selectionCount === 0} className="flex items-center gap-2 px-3 py-1.5 text-xs bg-white border border-slate-300 rounded hover:bg-indigo-50 hover:text-indigo-600 disabled:opacity-50 transition-colors"><Icon name="expand" size={14} /> {t('ungroup')}</button>
                            <div className="w-px bg-slate-300 mx-2"></div>
                            <button onClick={handleExtract} disabled={selectionCount === 0} className="flex items-center gap-2 px-3 py-1.5 text-xs bg-emerald-50 border border-emerald-200 text-emerald-700 rounded hover:bg-emerald-100 disabled:opacity-50 transition-colors"><Icon name="external-link" size={14} /> {t('extract')}</button>
                        </div>

                        {/* Editor Canvas Area */}
                        <div 
                            ref={editorWrapperRef}
                            className={`flex-1 overflow-hidden relative cursor-default ${editorWhiteBg ? 'bg-white' : 'bg-checkerboard'}`}
                            onWheel={handleWheel}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Selection Box */}
                            {isBoxSelecting && (
                                <div className="selection-box" style={{ left: selectionBox.x, top: selectionBox.y, width: selectionBox.w, height: selectionBox.h }}></div>
                            )}

                            <div className="w-full h-full flex items-center justify-center pointer-events-none">
                                <div style={{ width: '80%', height: '80%', transform: `translate(${pan.x}px, ${pan.y}px) scale(${scale})`, transition: isPanning ? 'none' : 'transform 0.1s ease-out', pointerEvents: 'auto' }}>
                                    <div ref={containerRef} className="w-full h-full border border-slate-300 shadow-2xl bg-transparent"></div>
                                </div>
                            </div>
                            {isPanning && <div className="absolute inset-0 z-50 cursor-grabbing"></div>}
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [lang, setLang] = useState('zh-TW');
            const [canvas, setCanvas] = useState({ w: 1080, h: 1920 });
            const [groups, setGroups] = useState([{ id: 1, name: "Main", x: 140, y: 560, w: 200, h: 200, files: [], selectedIdx: 0 }]);
            const [editingFile, setEditingFile] = useState(null);
            const [scale, setScale] = useState(0.35);
            const [pan, setPan] = useState({ x: 0, y: 0 }); 
            const [isPanning, setIsPanning] = useState(false);
            const [startPan, setStartPan] = useState({ x: 0, y: 0 });
            const [showGrid, setShowGrid] = useState(true);
            const [autoTrim, setAutoTrim] = useState(true);
            const [previewWhiteBg, setPreviewWhiteBg] = useState(true);
            const [dragOverGroupId, setDragOverGroupId] = useState(null);

            const t = (key) => TRANSLATIONS[lang][key] || key;

            const parseSvg = async (file) => {
                const text = await file.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, "image/svg+xml");
                const svgTag = doc.querySelector("svg");
                const content = svgTag.innerHTML;
                if (!autoTrim) {
                    let w = parseFloat(svgTag.getAttribute("width"));
                    let h = parseFloat(svgTag.getAttribute("height"));
                    const viewBox = svgTag.getAttribute("viewBox") || `0 0 ${w||100} ${h||100}`;
                    if (!w) { const parts = viewBox.split(/[\s,]+/).map(parseFloat); if (parts.length === 4) { w = parts[2]; h = parts[3]; } }
                    return { name: file.name, viewBox, content, originalW: w || 100, originalH: h || 100 };
                }
                return new Promise((resolve) => {
                    const tempDiv = document.createElement("div"); tempDiv.style.position = "absolute"; tempDiv.style.visibility = "hidden"; tempDiv.style.pointerEvents = "none";
                    document.body.appendChild(tempDiv); tempDiv.innerHTML = `<svg><g id="measure-target">${content}</g></svg>`;
                    requestAnimationFrame(() => {
                        try {
                            const measureTarget = tempDiv.querySelector("#measure-target"); const bbox = measureTarget.getBBox(); const padding = 0.5;
                            const newX = parseFloat((bbox.x - padding).toFixed(3)); const newY = parseFloat((bbox.y - padding).toFixed(3));
                            const newW = parseFloat((bbox.width + padding * 2).toFixed(3)); const newH = parseFloat((bbox.height + padding * 2).toFixed(3));
                            const newViewBox = `${newX} ${newY} ${newW} ${newH}`;
                            document.body.removeChild(tempDiv);
                            resolve({ name: file.name, viewBox: newViewBox, content: content, originalW: newW, originalH: newH });
                        } catch (e) {
                            document.body.removeChild(tempDiv); const w = 100, h = 100;
                            resolve({ name: file.name, viewBox: `0 0 ${w} ${h}`, content, originalW: w, originalH: h });
                        }
                    });
                });
            };

            const handleUploadFiles = async (groupId, files) => {
                const newFiles = await Promise.all(Array.from(files).map(f => parseSvg(f)));
                setGroups(groups.map(g => {
                    if (g.id === groupId) {
                        const firstFile = newFiles[0];
                        const isNew = g.files.length === 0;
                        return { ...g, files: [...g.files, ...newFiles], w: isNew && firstFile ? firstFile.originalW : g.w, h: isNew && firstFile ? firstFile.originalH : g.h };
                    } return g;
                }));
            };

            const updateGroup = (id, field, val) => {
                const numericFields = ['x', 'y', 'w', 'h'];
                const newVal = numericFields.includes(field) ? (val === '' ? 0 : parseFloat(val)) : val;
                setGroups(groups.map(g => g.id === id ? { ...g, [field]: newVal } : g));
            };

            const saveEditedFile = (newContent) => {
                if (!editingFile) return;
                setGroups(groups.map(g => {
                    if (g.id === editingFile.groupId) {
                        const newFiles = [...g.files];
                        newFiles[editingFile.fileIndex] = { ...newFiles[editingFile.fileIndex], content: newContent };
                        return { ...g, files: newFiles };
                    } return g;
                }));
                setEditingFile(null);
            };

            const handlePromoteGroup = (data) => {
                const newId = Date.now();
                setGroups(prev => [...prev, {
                    id: newId, name: `Extracted ${groups.length}`, x: parseFloat(data.x.toFixed(3)), y: parseFloat(data.y.toFixed(3)),
                    w: parseFloat(data.w.toFixed(3)), h: parseFloat(data.h.toFixed(3)), selectedIdx: 0,
                    files: [{ name: "extracted_part.svg", viewBox: data.viewBox, content: data.content, originalW: data.w, originalH: data.h }]
                }]);
            };

            const addDecorationLayer = () => {
                const newId = Date.now();
                setGroups([...groups, { id: newId, name: `Other ${groups.length}`, x: 0, y: 0, w: canvas.w, h: canvas.h, files: [], selectedIdx: 0 }]);
            };

            const handleWheel = (e) => { const delta = e.deltaY > 0 ? -0.05 : 0.05; setScale(prev => Math.min(Math.max(0.05, prev + delta), 3)); };
            const handleMouseDown = (e) => { if (e.button === 1) { e.preventDefault(); setIsPanning(true); setStartPan({ x: e.clientX - pan.x, y: e.clientY - pan.y }); } };
            const handleMouseMove = (e) => { if (!isPanning) return; e.preventDefault(); setPan({ x: e.clientX - startPan.x, y: e.clientY - startPan.y }); };
            const handleMouseUp = () => setIsPanning(false);

            const generateSvgString = (iterationIdx, isPreview = false, isForDownload = false) => {
                let layers = "";
                groups.forEach((g, gIdx) => {
                    const fileIdx = (gIdx === 0 && !isPreview) ? iterationIdx : g.selectedIdx;
                    const file = g.files[fileIdx];
                    if (file) layers += `<g transform="translate(${g.x}, ${g.y})"><svg width="${g.w}" height="${g.h}" viewBox="${file.viewBox}" preserveAspectRatio="none">${file.content}</svg></g>`;
                    if (isPreview && showGrid) layers += `<rect x="${g.x}" y="${g.y}" width="${g.w}" height="${g.h}" fill="none" stroke="${gIdx===0?'#6366f1':'#f43f5e'}" stroke-width="2" stroke-dasharray="5,5" /><text x="${g.x}" y="${g.y-10}" fill="${gIdx===0?'#6366f1':'#f43f5e'}" font-size="20" font-weight="bold">${g.name}</text>`;
                });
                const bgLayer = (isPreview && previewWhiteBg && !isForDownload) ? '<rect width="100%" height="100%" fill="white" />' : '';
                return `<svg width="${canvas.w}" height="${canvas.h}" viewBox="0 0 ${canvas.w} ${canvas.h}" xmlns="http://www.w3.org/2000/svg">${bgLayer}${layers}</svg>`;
            };

            const downloadSingle = (index) => {
                const content = generateSvgString(index, false, true); 
                const blob = new Blob([content], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                let fileName = groups[0].files[index] ? groups[0].files[index].name : `export_${index + 1}.svg`;
                if (!fileName.toLowerCase().endsWith('.svg')) fileName += '.svg';
                a.href = url; a.download = fileName; a.click();
            };
            const batchDownload = () => {
                if (groups[0].files.length === 0) return alert(t('noFileAlert'));
                groups[0].files.forEach((_, index) => setTimeout(() => downloadSingle(index), index * 200));
            };

            return (
                <div className="flex h-screen w-full overflow-hidden">
                    {editingFile && <SvgEditorModal file={editingFile.fileData} parentGroupInfo={groups.find(g => g.id === editingFile.groupId)} onSave={saveEditedFile} onPromote={handlePromoteGroup} onClose={() => setEditingFile(null)} t={t} />}
                    <div className="w-96 bg-white border-r flex flex-col shadow-2xl z-20">
                        <div className="p-6 bg-slate-900 text-white space-y-3">
                            <div className="flex justify-between items-start">
                                <div><h1 className="font-bold text-lg">{t('title')}</h1><div className="text-[10px] text-slate-400 mt-1">{t('subtitle')}</div></div>
                                <select className="lang-select" value={lang} onChange={(e) => setLang(e.target.value)}><option value="zh-TW">繁(TW)</option><option value="zh-CN">簡(CN)</option><option value="en-US">英(EN)</option></select>
                            </div>
                            <div className="flex flex-col gap-2 pt-2">
                                <label className="flex items-center gap-2 text-xs cursor-pointer hover:text-indigo-300"><input type="checkbox" checked={autoTrim} onChange={e => setAutoTrim(e.target.checked)} className="rounded text-indigo-500" /> <span>{t('smartTrim')}</span></label>
                                <label className="flex items-center gap-2 text-xs cursor-pointer hover:text-indigo-300"><input type="checkbox" checked={previewWhiteBg} onChange={e => setPreviewWhiteBg(e.target.checked)} className="rounded text-indigo-500" /> <span>{t('previewWhiteBg')}</span></label>
                            </div>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-6 custom-scrollbar">
                             <div className="grid grid-cols-2 gap-4 p-4 bg-slate-50 rounded-xl border">
                                <div className="col-span-2 text-[10px] font-bold text-slate-400 uppercase">{t('canvasSize')}</div>
                                <input type="number" value={canvas.w} onChange={e => setCanvas({...canvas, w: parseInt(e.target.value)})} className="border rounded px-2 py-1 text-sm" placeholder="W" />
                                <input type="number" value={canvas.h} onChange={e => setCanvas({...canvas, h: parseInt(e.target.value)})} className="border rounded px-2 py-1 text-sm" placeholder="H" />
                            </div>
                            {groups.map((g, idx) => (
                                <div key={g.id} className={`border-2 rounded-2xl p-4 transition-all ${idx === 0 ? 'border-indigo-100 bg-indigo-50/30' : 'border-slate-100'}`}>
                                    <div className="flex justify-between items-center mb-4">
                                        <input value={g.name} onChange={e => updateGroup(g.id, 'name', e.target.value)} className="font-bold bg-transparent w-40 outline-none border-b border-transparent hover:border-slate-300 focus:border-indigo-500 px-1" />
                                        {idx > 0 && <button className="text-xs text-red-400 hover:text-red-600 bg-red-50 px-2 py-1 rounded" onClick={() => { if(confirm(t('deleteLayerConfirm'))) setGroups(groups.filter(group => group.id !== g.id)); }}>{t('deleteLayer')}</button>}
                                    </div>
                                    <div className="grid grid-cols-4 gap-2 mb-4">
                                        {['x', 'y', 'w', 'h'].map(f => (
                                            <div key={f}><label className="text-[10px] text-center block text-slate-400 uppercase">{f}</label><input type="number" step="0.001" value={g[f]} onChange={e => updateGroup(g.id, f, e.target.value)} className="w-full border rounded text-center text-xs py-1 font-mono" /></div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2">
                                        <UploadZone groupId={g.id} onUpload={handleUploadFiles} t={t} />
                                        <button onClick={() => { if(confirm(t('clearFilesConfirm'))) updateGroup(g.id, 'files', []); }} className="w-12 flex items-center justify-center border-2 border-red-100 text-red-400 rounded-xl hover:bg-red-50 hover:border-red-300 transition-all"><Icon name="trash-2" size={16} /></button>
                                    </div>
                                    {g.files.length === 1 && <button onClick={() => setEditingFile({ groupId: g.id, fileIndex: 0, fileData: g.files[0] })} className="w-full mt-2 py-2 bg-indigo-100 text-indigo-700 text-xs font-bold rounded-lg hover:bg-indigo-200 transition-colors flex items-center justify-center gap-2 shadow-sm"><Icon name="edit-3" size={14} /> {t('editSvg')}</button>}
                                    {g.files.length > 0 && <div className="mt-2 text-[10px] text-slate-500 text-center">{t('fileCount').replace('{count}', g.files.length).replace('{name}', g.files[g.selectedIdx].name)}</div>}
                                </div>
                            ))}
                            <button onClick={addDecorationLayer} className="w-full py-3 border-2 border-dashed border-slate-300 text-slate-500 rounded-xl text-sm font-bold hover:bg-slate-50 hover:border-indigo-400 hover:text-indigo-500 transition-all flex items-center justify-center gap-2"><Icon name="plus-circle" size={18} /> {t('addOther')}</button>
                        </div>
                        <div className="p-6 border-t bg-white">
                            <button onClick={batchDownload} className="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold shadow hover:bg-indigo-700 flex justify-center gap-2"><Icon name="download" size={20} /> {t('batchDownload')}</button>
                        </div>
                        <div className="p-4 text-center">
                            <div className="text-[10px] text-slate-400">
                                Created by <span className="font-bold text-slate-500">@Rock_4762</span>
                            </div>
                        </div>
                    </div>
                    <main className="flex-1 relative overflow-hidden canvas-area flex items-center justify-center" onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}>
                         <div className="fixed top-6 right-6 flex items-center gap-4 bg-white/80 backdrop-blur p-2 rounded-xl border shadow-sm z-30 pointer-events-auto">
                            <button onClick={() => setScale(Math.max(0.05, scale - 0.05))} className="p-1 hover:bg-slate-100 rounded"><Icon name="minus" /></button>
                            <span className="text-xs font-mono font-bold w-12 text-center">{Math.round(scale*100)}%</span>
                            <button onClick={() => setScale(Math.min(3, scale + 0.05))} className="p-1 hover:bg-slate-100 rounded"><Icon name="plus" /></button>
                            <button onClick={() => setPan({x:0, y:0})} className="p-1 hover:bg-slate-100 rounded text-xs" title={t('reset')}>{t('reset')}</button>
                        </div>
                        <div style={{ width: canvas.w, height: canvas.h, transform: `translate(${pan.x}px, ${pan.y}px) scale(${scale})`, transition: isPanning ? 'none' : 'transform 0.1s ease-out', transformOrigin: 'center center' }} className={`shadow-2xl ${previewWhiteBg ? 'bg-white' : 'bg-transparent'}`} dangerouslySetInnerHTML={{ __html: generateSvgString(0, true) }} />
                    </main>
                </div>
            );
        };
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>